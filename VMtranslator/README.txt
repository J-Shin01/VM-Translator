
################################################### < Project 7 > #############################################################

* VM 언어 명령어 종류
	-산술명령 : 스택에서 산술 및 논리 연산을 수행
	-메모리 접근 명령 : 스택과 가상 메모리 세그먼트 사이에 데이터를 주고받는 명령
	-프로그램 흐름 명령 : 조건 및 무조건 분기 연산을 가능하게 함
	-함수 호출 명령 : 함수를 호출하고 결과를 반환

##1. 산술 명령 : 7장에서 구현
명령   | 반환값 (피연사자를 꺼낸 후)
---------------------------------------------------------------------------------------------------------------
add    | X+Y                        : sp-2와 sp-1을 더해서 결과값을 sp-2에 넣는다. sp-1의 값은 없앤다.
sub    | X-Y                        : sp-2와 sp-1을 더해서 결과값을 sp-2에 넣는다. sp-1의 값은 없앤다.
neg    | -Y                         : sp-1의 값을 -1로 바꾼다
eq     | true if x=y, else false    : sp-2와 sp-1을 비교해서 결과값을 sp-2에 넣는다. sp-1의 값은 없앤다.
gt     | true if x>y, else false    : sp-2와 sp-1을 비교해서 결과값을 sp-2에 넣는다. sp-1의 값은 없앤다.
lt     | true if x<y, else false    : sp-2와 sp-1을 비교해서 결과값을 sp-2에 넣는다. sp-1의 값은 없앤다.
and    | X AND Y                    : sp-2와 sp-1을 비교해서 결과값을 sp-2에 넣는다. sp-1의 값은 없앤다.
or     | X OR  Y                    : sp-2와 sp-1을 비교해서 결과값을 sp-2에 넣는다. sp-1의 값은 없앤다.
not    | NOT Y                      : sp-1의 값을 반전시켜 값을 sp-1에 넣는다. 

( ※ true와 false는 -1, 0 으로 표시)
					


##2. 세그먼트 명령어 : 7장에서 구현
- push segment index : segment[index] 값을 스택에 넣는다.
- pop segment index : 최상단 스택 값을 꺼내서 segment[index]에 저장한다.
(여기서 segment는 8개 세그먼트 이름 중 하나이다.)

(※가상메모리는 시작 주소는 있어도 끝 주소는 없는 물리적인 할당이 없는 메모리라고 보면된다. 임의로 주소를 붙인것)


세그먼트   | 용도                                                                     | 설명
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
argument   | 함수의 인수를 저장                                                       | 함수가 입력되면 VM이 동적 할당한다.
local      | 함수의 지역 변수를 저장                                                  | 함수가 입력되면 VM이 동적으로 할당하고 0으로 초기화함
static     | 같은 .vm 파일 내 모든 함수가 공유하는 정적 변수를 저장                   | 각 .vm 파일에 대해 VM이 할당함. .vm파일 내 모든 함수가 공유함 (공통)
constant   | 0~32767 범위 내 모든 상수를 가짐                                         | VM이 에뮬레이션함. 프로그램 내 모든 함수에서 접근 가능
this       | 다목적 세그먼트                                                          | 모든 VM 함수는 힙 상에서 선택된 영역을 조작하는 용도로 이 세그먼트를 사용 가능함.
that       | 다목적 세그먼트                                                          | //
Pointer    | this와 that 세그먼트의 기준 주소값을 가지고 있는 두 개의 입력 세그먼트   | 모든 VM 함수는 pointer 0 (또는 1)을 특정 주소로 설정가능하다. this(또는 that) 세그먼트가 그 주소에서 시작하는 힙 영역으로 정렬됨
temp       | 일반적 용도의 임시 변수를 가지는 고정 8-입력 세그먼트                    | VM 함수 내에서 어떤 목적으로든 사용될 수 있음. 프로그램내 모든 함수가 공유함
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	*메모리 세그먼트 매핑

0.가상메모리 세그먼트란
-세그먼트는 구획을 나눈다는 의미가 있다.
-HACK 컴퓨터는 RAM을 메모리로 가지고 있다.
-이 RAM 내에서 가상메모리 세그먼트를 정한다.
-메모리 세그먼트의 Base Address는 있지만, 영역은 정해져있지 않다. 
-그래서 가상메모리라고 하는 것.


1.local, arguments, this, that : Stack 내부에 맵핑?
-이 세그먼트들은 각각 RAM에 "직접 매핑"되며 전용 레지스터 (LCL, ARG, THIS, THAT)에 실제 시작 주소가 지정된다.
-그러므로 각 세그먼트의 i번째 항목에 접근하는 명령은 RAM 상의 (base + i)주소에 
-접근하는 어셈블리 코드로 번역되며, base는 현재 세그먼트 전용 레지스터에 저장된 값이 된다.

2.pointer, temp  :
-이 세그먼트들은 RAM 내의 "고정영역"으로 바로 매핑.
-pointer 세그먼트는 RAM 위치 3-4(THIS, THAT)에 해당한다. pointer i에 접근하는 명령은 RAM 위치 3+i 에 접근하는 어셈블리 코드로 번역된다.
-temp 세그먼트는 5-12(R5-R12)에 해당한다. temp i명령은 RAM 위치 5+i에 접근하는 어셈블리 코드로 번역된다.

3.constant
-이 세그먼트는 대상 아키텍처의 실제 공간을 차지하지 않으므로, 가상 세그먼트.
-VM에서는 constant i에 대해 상수 i를 제공하는 방식으로 처리

4.static
-어셈블러는 주소 16부터 시작하는 새로운 RAM 주소를 그 기호에 할당한다.
-VM파일에 f에있는 정적변수 j를 어셈블리에서는 기호 f.j로 표현할 수 있다.
-RAM[16-255]

		ex) 
		xxx.vm파일에 push static 3이라는 명령이 있으면
		@xxx.3과 D=M, D의 값을 스택에 푸시하는 코드로 번역 가능하다.


	*메모리 표준 매핑
RAM 주소       | 사용법
---------------------------------------------------------------------------------------------------
0-15           | 16개의 가상 레지스터
16-255         | 정적 변수 (프로그램 내 모든 VM 함수에서 사용 : static segment)
256-2047       | 스택
2048-16383     | 힙 (객체와 배열 저장에 활용됨)
16384-24575    | 메모리 매핑 I/O
24575-32767    | 사용하지 않는 메모리 공간

(※스택은 정적 메모리 할당, 힙은 동적 메모리 할당에 쓴다)

	*16개의 가상 레지스터
레지스터      |  이름  | 사용법 
---------------------------------------------------------------------------------------------------
RAM[0]        | SP     | 스택 포인터 : 스택에서 다음 최상위 위치를 가리킨다. (STACK)
RAM[1]        | LCL    | 현재 VM 함수의 local 세그먼트의 기저 주소를 가리킨다. (Local에 대해)
RAM[2]        | ARG    | 현재 VM 함수의 argument 세그먼트의 기저 주소를 가리킨다.
RAM[3]        | THIS   | 현재 this 세그먼트의 시작 주소(힙 내부)를 가리킨다. (RAM[2048])
RAM[4]        | THAT   | 현재 that 세그먼트의 시작 주소(힙 내부)를 가리킨다. (RAM[2048])
RAM[5-12]     |        | temp 세그먼트의 내용을 저장한다.
RAM[13-15]    |        | VM 구현에서 다용도 레지스터로 사용될 수 있다.


	*예시
-----------------------------------------------------------
|				       *VM 파일*                          |
| Foo.vm                     | Bar.vm                     |
| VM 함수 f1, f2, f3         | VM 함수 f1, f2             |
-----------------------------------------------------------
					 |VM 파일 입력|
___________________________________________________________
|             static             |         static         |
| argument | argument | argument |  argument  | argument  |
| local    | local    | local    |  local     | local     |
| this     | this     | this     |  this      | this      |
| that     | that     | that     |  that      | that      |
| pointer  | pointer  | pointer  |  pointer   | pointer   |
|                         temp                            |
|                        constant                         |
-----------------------------------------------------------
					 |기계어 출력|
-----------------------------------------------------------
|                    핵 기계어 코드                       |
-----------------------------------------------------------


################################################### < Project 8 > #############################################################



##3. 프로그램 흐름 명령 : 8장에서 구현
	label symbol // 레이블 선언
	goto symbol // 무조건 분기
	if-goto symbol // 조건 분기

##4. 함수 호출 명령 : 8장에서 구현
	function functionName nLocals // 함수 선언. 함수의 지역 변수 개수를 지정
	call functionName nArgs // 함수 호출. 함수의 인수 개수를 지정함
	return //호출하는 함수로 제어를 되돌림
	(nLocals, nArgs는 음수가 아닌 정수)